<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="c++后台">
<meta property="og:type" content="website">
<meta property="og:title" content="條路自己揀，僕街唔好喊。">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="條路自己揀，僕街唔好喊。">
<meta property="og:description" content="c++后台">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="條路自己揀，僕街唔好喊。">
<meta name="twitter:description" content="c++后台">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>條路自己揀，僕街唔好喊。</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">條路自己揀，僕街唔好喊。</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/19/简单的tcp客户端与服务端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Just_Lm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="條路自己揀，僕街唔好喊。">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/19/简单的tcp客户端与服务端/" itemprop="url">简单的tcp客户端与服务端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-19T01:44:44+08:00">
                2018-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>功能：客户端向服务器发送消息，服务器接收并显示。</p>
</blockquote>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) do &#123;  perror(m); exit(EXIT_FAILURE); &#125;while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> listenfd;</span><br><span class="line">        <span class="keyword">if</span> ((listenfd = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP)) &lt; <span class="number">0</span>)<span class="comment">//第三个参数也可直接是0</span></span><br><span class="line">		ERR_EXIT(<span class="string">"socket"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="keyword">sizeof</span> servaddr);</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(<span class="number">5188</span>);</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (bind(listenfd,(struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span> (servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">		ERR_EXIT(<span class="string">"bind"</span>);</span><br><span class="line">	<span class="keyword">if</span> (listen(listenfd,SOMAXCONN) &lt; <span class="number">0</span> )</span><br><span class="line"> 		ERR_EXIT(<span class="string">"listen"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">peeraddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> peerlen = <span class="keyword">sizeof</span>(peeraddr);</span><br><span class="line">	<span class="keyword">int</span> conn;</span><br><span class="line">        <span class="keyword">if</span> ((conn = accept(listenfd,(struct sockaddr*)&amp;peeraddr,&amp;peerlen)) &lt; <span class="number">0</span>)</span><br><span class="line">     		ERR_EXIT(<span class="string">"accept"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> recvbuf[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf, <span class="number">0</span> , <span class="keyword">sizeof</span> recvbuf);</span><br><span class="line">		<span class="keyword">int</span> ret = read(conn, recvbuf, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">		<span class="built_in">fputs</span>(recvbuf,<span class="built_in">stdout</span>);</span><br><span class="line">		write(conn,recvbuf,ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(conn);</span><br><span class="line">	close(listenfd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) do &#123;  perror(m); exit(EXIT_FAILURE); &#125;while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> sock;</span><br><span class="line">        <span class="keyword">if</span> ((sock  = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP)) &lt; <span class="number">0</span>)</span><br><span class="line">		ERR_EXIT(<span class="string">"socket"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="keyword">sizeof</span> servaddr);</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(<span class="number">5188</span>);</span><br><span class="line">	servaddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (connect(sock, (struct sockaddr*)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">		ERR_EXIT(<span class="string">"connext"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> sendbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> recvbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  	<span class="keyword">while</span>(fgets(sendbuf,<span class="keyword">sizeof</span> (sendbuf),<span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write(sock,sendbuf,<span class="built_in">strlen</span>(sendbuf));</span><br><span class="line">		read(sock, recvbuf,<span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">fputs</span>(recvbuf,<span class="built_in">stdout</span>);</span><br><span class="line">		<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="keyword">sizeof</span> sendbuf);</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf,<span class="number">0</span>,<span class="keyword">sizeof</span> recvbuf);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	close(sock);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>###tip:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       socket - create an endpoint <span class="keyword">for</span> communication</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       socket()  creates  an endpoint <span class="keyword">for</span> communication <span class="keyword">and</span> returns a descrip‐</span><br><span class="line">       tor.</span><br><span class="line"></span><br><span class="line">       The domain argument specifies a communication domain; <span class="keyword">this</span> selects  the</span><br><span class="line">       protocol  family  which will be used <span class="keyword">for</span> communication.  These families</span><br><span class="line">       are  defined  in  &lt;sys/socket.h&gt;.   The  currently  understood  formats</span><br><span class="line">       include:</span><br><span class="line"></span><br><span class="line">       Name                Purpose                          Man page</span><br><span class="line">       AF_UNIX, <span class="function">AF_LOCAL   Local communication              <span class="title">unix</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line"><span class="function">       AF_INET             IPv4 Internet protocols          <span class="title">ip</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line"><span class="function">       AF_INET6            IPv6 Internet protocols          <span class="title">ipv6</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line">       AF_IPX              IPX - Novell protocols</span><br><span class="line">       <span class="function">AF_NETLINK          Kernel user interface device     <span class="title">netlink</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line">       AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)</span><br><span class="line">       AF_AX25             Amateur radio AX<span class="number">.25</span> protocol</span><br><span class="line">       AF_ATMPVC           Access to raw ATM PVCs</span><br><span class="line">       <span class="function">AF_APPLETALK        AppleTalk                        <span class="title">ddp</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line"><span class="function">       AF_PACKET           Low level packet interface       <span class="title">packet</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line"><span class="function">       AF_ALG              Interface to kernel crypto API</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">       The  socket  has  the indicated type, which specifies the communication</span><br><span class="line">       semantics.  Currently defined types are:</span><br><span class="line"></span><br><span class="line">       SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based</span><br><span class="line">                       byte  streams.  An out-of-band data transmission mecha‐</span><br><span class="line">                       nism may be supported.</span><br><span class="line"></span><br><span class="line">       <span class="function">SOCK_DGRAM      Supports <span class="title">datagrams</span> <span class="params">(connectionless, unreliable messages</span></span></span><br><span class="line">                       of a fixed maximum length).</span><br><span class="line"></span><br><span class="line">       SOCK_SEQPACKET  Provides  a  sequenced,  reliable,  two-way connection-</span><br><span class="line">                       based data transmission path  <span class="keyword">for</span>  datagrams  of  fixed</span><br><span class="line">                       maximum  length;  a  consumer  is  required  to read an</span><br><span class="line">                       entire packet with each input system call.</span><br><span class="line"></span><br><span class="line">       SOCK_RAW        Provides raw network protocol access.</span><br><span class="line"></span><br><span class="line">       SOCK_RDM        Provides a reliable datagram layer that does <span class="keyword">not</span>  guar‐</span><br><span class="line">                       antee ordering.</span><br><span class="line"></span><br><span class="line">       SOCK_PACKET     Obsolete  <span class="keyword">and</span>  should  <span class="keyword">not</span> be used in <span class="keyword">new</span> programs; see</span><br><span class="line">                       packet(<span class="number">7</span>).</span><br><span class="line">                     </span><br><span class="line">                     </span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, a file descriptor <span class="keyword">for</span> the <span class="keyword">new</span> socket is returned.  On error, <span class="number">-1</span> is returned, <span class="keyword">and</span> errno is <span class="built_in">set</span> appropriately.</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">short</span> sin_family;<span class="comment">/*Address family一般来说AF_INET（地址族）PF_INET（协议族）*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;<span class="comment">/*Port number(必须要采用网络数据格式,普通数字可以用htons()函数转换成网络数据格式的数字)*/</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/*IP address in network byte order（Internet address）*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">/*Same size as struct sockaddr没有实际意义,只是为了　跟SOCKADDR结构在内存中对齐*/</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       htonl,  htons,  ntohl,  ntohs - convert values between host <span class="keyword">and</span> network</span><br><span class="line">       byte order</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       <span class="function">The <span class="title">htonl</span><span class="params">()</span> function converts the <span class="keyword">unsigned</span> integer hostlong  from  host</span></span><br><span class="line">       byte order to network byte order.</span><br><span class="line"></span><br><span class="line">       <span class="function">The <span class="title">htons</span><span class="params">()</span> function converts the <span class="keyword">unsigned</span> <span class="keyword">short</span> integer hostshort from</span></span><br><span class="line">       host byte order to network byte order.</span><br><span class="line"></span><br><span class="line">       <span class="function">The <span class="title">ntohl</span><span class="params">()</span> function converts the <span class="keyword">unsigned</span> integer netlong from network</span></span><br><span class="line">       byte order to host byte order.</span><br><span class="line"></span><br><span class="line">       <span class="function">The  <span class="title">ntohs</span><span class="params">()</span> function converts the <span class="keyword">unsigned</span> <span class="keyword">short</span> integer netshort from</span></span><br><span class="line">       network byte order to host byte order.</span><br><span class="line"></span><br><span class="line">       On the i386 the host  byte  order  is  Least  Significant  Byte  first,</span><br><span class="line">       whereas  the  network byte order, as used on the Internet, is Most Sig‐</span><br><span class="line">       nificant Byte first.</span><br><span class="line"></span><br><span class="line">ATTRIBUTES</span><br><span class="line">       For  an  explanation  of  the  terms  used   in   <span class="keyword">this</span>   section,   see</span><br><span class="line">       attributes(<span class="number">7</span>).</span><br><span class="line"></span><br><span class="line">       ┌───────────────────────────────────┬───────────────┬─────────┐</span><br><span class="line">       │Interface                          │ Attribute     │ Value   │</span><br><span class="line">       ├───────────────────────────────────┼───────────────┼─────────┤</span><br><span class="line">       │htonl(), htons(), ntohl(), ntohs() │ Thread safety │ MT-Safe │</span><br><span class="line">       └───────────────────────────────────┴───────────────┴─────────┘</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       inet_aton, inet_addr, inet_network, inet_ntoa, inet_makeaddr, inet_lnaof, inet_netof - Internet address manipulation routines</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">in_addr_t</span> inet_addr(<span class="keyword">const</span> <span class="keyword">char</span> *cp);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">in_addr_t</span> inet_network(<span class="keyword">const</span> <span class="keyword">char</span> *cp);</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function">struct in_addr <span class="title">inet_makeaddr</span><span class="params">(<span class="keyword">in_addr_t</span> net, <span class="keyword">in_addr_t</span> host)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">in_addr_t</span> inet_lnaof(struct in_addr in);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">in_addr_t</span> inet_netof(struct in_addr in);</span><br><span class="line"></span><br><span class="line">   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span><br><span class="line"></span><br><span class="line">       inet_aton(), inet_ntoa(): _BSD_SOURCE || _SVID_SOURCE</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       inet_aton()  converts  the  Internet  host  address  cp  from  the  IPv4  numbers-and-dots notation into binary form (in network byte order) and stores it in the structure that inp points to.</span><br><span class="line">       inet_aton() returns nonzero <span class="keyword">if</span> the address is valid, zero <span class="keyword">if</span> <span class="keyword">not</span>.  The address supplied in cp can have one of the following forms:</span><br><span class="line"></span><br><span class="line">       a.b.c.d   Each of the four numeric parts specifies a byte of the address; the bytes are assigned in left-to-right order to produce the binary address.</span><br><span class="line"></span><br><span class="line">       a.b.c     Parts a <span class="keyword">and</span> b specify the first two bytes of the binary address.  Part c is interpreted as a <span class="number">16</span>-bit value that defines the rightmost two bytes of the binary address.  This  notation</span><br><span class="line">                 is suitable for specifying (outmoded) Class B network addresses.</span><br><span class="line"></span><br><span class="line">       a.b       Part a specifies the first byte of the binary address.  Part b is interpreted as a <span class="number">24</span>-bit value that defines the rightmost three bytes of the binary address.  This notation is suit‐</span><br><span class="line">                 able for specifying (outmoded) Class A network addresses.</span><br><span class="line"></span><br><span class="line">       a         The value a is interpreted as a <span class="number">32</span>-bit value that is stored directly into the binary address without any byte rearrangement.</span><br><span class="line"></span><br><span class="line">       In all of the above forms, components of the dotted address can be specified in decimal, octal (with a leading <span class="number">0</span>), <span class="keyword">or</span> hexadecimal, with a leading <span class="number">0</span>X).  Addresses in any  of  these  forms  are</span><br><span class="line">       collectively termed IPV4 numbers-and-dots notation.  The form that uses exactly four decimal numbers is referred to as IPv4 dotted-decimal notation (or sometimes: IPv4 dotted-quad notation).</span><br><span class="line"></span><br><span class="line">       inet_aton() returns 1 if the supplied string was successfully interpreted, or 0 if the string is invalid (errno is not set on error).</span><br><span class="line"></span><br><span class="line">       The  inet_addr()  function converts the Internet host address cp from IPv4 numbers-and-dots notation into binary data in network byte order.  If the input is invalid, INADDR_NONE (usually -1)</span><br><span class="line">       is returned.  Use of this function is problematic because -1 is a valid address (255.255.255.255).  Avoid its use in favor of inet_aton(), inet_pton(3), or  getaddrinfo(3),  which  provide  a</span><br><span class="line">       cleaner way to indicate error <span class="keyword">return</span>.</span><br><span class="line"></span><br><span class="line">       The  inet_network()  function  converts cp, a <span class="built_in">string</span> in IPv4 numbers-<span class="keyword">and</span>-dots notation, into a number in host byte order suitable <span class="keyword">for</span> use as an Internet network address.  On success, the con‐</span><br><span class="line">       verted address is returned.  If the input is invalid, <span class="number">-1</span> is returned.</span><br><span class="line"></span><br><span class="line">       The inet_ntoa() function converts the Internet host address in, given in network byte order, to a <span class="built_in">string</span> in IPv4 dotted-decimal notation.  The <span class="built_in">string</span> is returned  in  a  statically  allocated</span><br><span class="line">       buffer, which subsequent calls will overwrite.</span><br><span class="line"></span><br><span class="line">       The inet_lnaof() function returns the local network address part of the Internet address in.  The returned value is in host byte order.</span><br><span class="line"></span><br><span class="line">       The inet_netof() function returns the network number part of the Internet address in.  The returned value is in host byte order.</span><br><span class="line"></span><br><span class="line"> The inet_makeaddr() function is the converse of inet_netof() <span class="keyword">and</span> inet_lnaof().  It returns an Internet host address in network byte order, created by combining the network number net with the</span><br><span class="line">       local address host, both in host byte order.</span><br><span class="line"></span><br><span class="line">       The structure in_addr as used in inet_ntoa(), inet_makeaddr(), inet_lnaof() <span class="keyword">and</span> inet_netof() is defined in &lt;netinet/in.h&gt; as:</span><br><span class="line"></span><br><span class="line">           <span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">               <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">ATTRIBUTES</span><br><span class="line">       For an explanation of the terms used in this section, see attributes(7).</span><br><span class="line"></span><br><span class="line">       ┌───────────────────────────────┬───────────────┬────────────────┐</span><br><span class="line">       │Interface                      │ Attribute     │ Value          │</span><br><span class="line">       ├───────────────────────────────┼───────────────┼────────────────┤</span><br><span class="line">       │inet_aton(), inet_addr(),      │ Thread safety │ MT-Safe locale │</span><br><span class="line">       │inet_network(), inet_ntoa()    │               │                │</span><br><span class="line">       ├───────────────────────────────┼───────────────┼────────────────┤</span><br><span class="line">       │inet_makeaddr(), inet_lnaof(), │ Thread safety │ MT-Safe        │</span><br><span class="line">       │inet_netof()                   │               │                │</span><br><span class="line">       └───────────────────────────────┴───────────────┴────────────────┘</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">INADDR_ANY选项</span><br><span class="line">    网络编程中常用到bind函数，需要绑定IP地址，这时可以设置INADDR_ANY</span><br><span class="line">    INADDR_ANY就是指定地址为<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>的地址，这个地址事实上表示不确定地址，或“所有地址”、“任意地址”。</span><br><span class="line">也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。</span><br><span class="line">    比如一台电脑有<span class="number">3</span>块网卡，分别连接三个网络，那么这台电脑就有<span class="number">3</span>个ip地址了，如果某个应用程序需要监听某</span><br><span class="line">个端口，那他要监听哪个网卡地址的端口呢？如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网</span><br><span class="line">卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定<span class="number">3</span>个ip，也就等于需要管理<span class="number">3</span>个</span><br><span class="line">套接字进行数据交换，这样岂不是很繁琐？</span><br><span class="line">    所以你只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，</span><br><span class="line">只要是绑定的端口号过来的数据，都可以接收到。</span><br><span class="line"></span><br><span class="line">    当然， 客户端connect时，不能使用INADDR_ANY选项。必须指明要连接哪个服务器IP。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       bind - bind a name to a socket</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       When  a socket is created with socket(2), it exists in a name space (address family) but has no address assigned to it.  bind() assigns the address specified by addr to the socket referred to</span><br><span class="line">       by the file descriptor sockfd.  addrlen specifies the size, in bytes, of the address structure pointed to by addr.  Traditionally, <span class="keyword">this</span> operation is called “assigning a name to a socket”.</span><br><span class="line"></span><br><span class="line">       It is normally necessary to assign a local address using bind() before a SOCK_STREAM socket may receive connections (see accept(2)).</span><br><span class="line"></span><br><span class="line">       The rules used in name binding vary between address families.  Consult the manual entries in Section 7 for detailed information.  For AF_INET see ip(7), for AF_INET6 see ipv6(7), for  AF_UNIX</span><br><span class="line">       see unix(7), for AF_APPLETALK see ddp(7), for AF_PACKET see packet(7), for AF_X25 see x25(7) and for AF_NETLINK see netlink(7).</span><br><span class="line"></span><br><span class="line">       The actual structure passed <span class="keyword">for</span> the addr argument will depend on the address family.  The sockaddr structure is defined as something like:</span><br><span class="line"></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">               <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">               <span class="keyword">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       The only purpose of <span class="keyword">this</span> structure is to cast the structure pointer passed in addr in order to avoid compiler warnings.  See EXAMPLE below.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, zero is returned.  On error, <span class="number">-1</span> is returned, <span class="keyword">and</span> errno is <span class="built_in">set</span> appropriately.</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       listen - listen <span class="keyword">for</span> connections on a socket</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       listen() marks the socket referred to by sockfd as a passive socket, that is, as a socket that will be used to accept incoming connection requests using accept(2).</span><br><span class="line"></span><br><span class="line">       The sockfd argument is a file descriptor that refers to a socket of type SOCK_STREAM <span class="keyword">or</span> SOCK_SEQPACKET.</span><br><span class="line"></span><br><span class="line">       The  backlog argument defines the maximum length to which the <span class="built_in">queue</span> of pending connections <span class="keyword">for</span> sockfd may grow.  If a connection request arrives when the <span class="built_in">queue</span> is full, the client may receive</span><br><span class="line">       an error with an indication of ECONNREFUSED <span class="keyword">or</span>, <span class="keyword">if</span> the underlying protocol supports retransmission, the request may be ignored so that a later reattempt at connection succeeds.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, zero is returned.  On error, <span class="number">-1</span> is returned, <span class="keyword">and</span> errno is <span class="built_in">set</span> appropriately.</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">对于一个TCP连接，Server与Client需要通过三次握手来建立网络连接.当三次握手成功后,</span><br><span class="line"></span><br><span class="line">　　我们可以看到端口的状态由LISTEN转变为ESTABLISHED,接着这条链路上就可以开始传送数据了.</span><br><span class="line"></span><br><span class="line">　　每一个处于监听(Listen)状态的端口,都有自己的监听队列.监听队列的长度,与如下两方面有关:</span><br><span class="line"></span><br><span class="line">　　- somaxconn参数.</span><br><span class="line"></span><br><span class="line">　　- 使用该端口的程序中listen()函数.</span><br><span class="line"></span><br><span class="line">　　<span class="number">1.</span> 关于somaxconn参数:</span><br><span class="line"></span><br><span class="line">　　定义了系统中每一个端口最大的监听队列的长度,这是个全局的参数,默认值为<span class="number">1024</span>,具体信息为:</span><br><span class="line"></span><br><span class="line">　　Purpose:</span><br><span class="line"></span><br><span class="line">　　Specifies the maximum listen backlog.</span><br><span class="line"></span><br><span class="line">　　Values:</span><br><span class="line"></span><br><span class="line">　　Default: <span class="number">1024</span> connections</span><br><span class="line"></span><br><span class="line">　　Range: <span class="number">0</span> to MAXSHORT</span><br><span class="line"></span><br><span class="line">　　Type: Connect</span><br><span class="line"></span><br><span class="line">　　Diagnosis:</span><br><span class="line"></span><br><span class="line">　　N/A</span><br><span class="line"></span><br><span class="line">　　Tuning</span><br><span class="line"></span><br><span class="line">　　Increase <span class="keyword">this</span> parameter on busy Web servers to handle peak connection rates.</span><br><span class="line"></span><br><span class="line">　　看下FREEBSD的解析：</span><br><span class="line"></span><br><span class="line">　　限制了接收新 TCP 连接侦听队列的大小。对于一个经常处理新连接的高负载 web服务环境来说，默认的 <span class="number">128</span> 太小了。大多数环境这个值建议增加到 <span class="number">1024</span> 或者更多。 服务进程会自己限制侦听队列的大小(例如 sendmail(<span class="number">8</span>) 或者 Apache)，常常在它们的配置文件中有设置队列大小的选项。大的侦听队列对防止拒绝服务 DoS 攻击也会有所帮助。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       accept, accept4 - accept a connection on a socket</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">accept4</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">socklen_t</span> *addrlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The  accept()  system call is used with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET).  It extracts the first connection request on the queue of pending connections for the lis‐</span><br><span class="line">       tening socket, sockfd, creates a <span class="keyword">new</span> connected socket, <span class="keyword">and</span> returns a <span class="keyword">new</span> file descriptor referring to that socket.  The newly created socket is <span class="keyword">not</span>  in  the  listening  state.   The  original</span><br><span class="line">       socket sockfd is unaffected by <span class="keyword">this</span> call.</span><br><span class="line"></span><br><span class="line">       The argument sockfd is a socket that has been created with socket(<span class="number">2</span>), bound to a local address with bind(<span class="number">2</span>), <span class="keyword">and</span> is listening <span class="keyword">for</span> connections after a listen(<span class="number">2</span>).</span><br><span class="line"></span><br><span class="line">       The  argument  addr  is  a  pointer  to  a sockaddr structure.  This structure is filled in with the address of the peer socket, as known to the communications layer.  The exact format of the</span><br><span class="line">       address returned addr is determined by the socket ‘s address family (see socket(<span class="number">2</span>) <span class="keyword">and</span> the respective protocol man pages).  When addr is <span class="literal">NULL</span>, nothing is filled in; in <span class="keyword">this</span>  <span class="keyword">case</span>,  addrlen  is</span><br><span class="line">       <span class="keyword">not</span> used, <span class="keyword">and</span> should also be <span class="literal">NULL</span>.</span><br><span class="line"></span><br><span class="line">       The addrlen argument is a value-result argument: <span class="function">the caller must initialize it to contain the <span class="title">size</span> <span class="params">(in bytes)</span> of the structure pointed to by addr</span>; on <span class="keyword">return</span> it will contain the actual size of</span><br><span class="line">       the peer address.</span><br><span class="line"></span><br><span class="line">       The returned address is truncated <span class="keyword">if</span> the buffer provided is too small; in <span class="keyword">this</span> <span class="keyword">case</span>, addrlen will <span class="keyword">return</span> a value greater than was supplied to the call.</span><br><span class="line"></span><br><span class="line">       If no pending connections are present on the <span class="built_in">queue</span>, <span class="keyword">and</span> the socket is <span class="keyword">not</span> marked as nonblocking, accept() blocks the caller until a connection is present.  If the socket is marked nonblocking</span><br><span class="line">       <span class="keyword">and</span> no pending connections are present on the <span class="built_in">queue</span>, accept() fails with the error EAGAIN <span class="keyword">or</span> EWOULDBLOCK.</span><br><span class="line"></span><br><span class="line">       In  order  to  be  notified of incoming connections on a socket, you can use select(<span class="number">2</span>) <span class="keyword">or</span> poll(<span class="number">2</span>).  A readable event will be delivered when a <span class="keyword">new</span> connection is attempted <span class="keyword">and</span> you may then call</span><br><span class="line">       accept() to get a socket for that connection.  Alternatively, you can set the socket to deliver SIGIO when activity occurs on a socket; see socket(7) for details.</span><br><span class="line"></span><br><span class="line">       For certain protocols which require an <span class="keyword">explicit</span> confirmation, such as DECNet, accept() can be thought of as merely dequeuing the next connection request <span class="keyword">and</span> <span class="keyword">not</span> implying  confirmation.   Con‐</span><br><span class="line">       firmation can be implied by a normal read <span class="keyword">or</span> write on the <span class="keyword">new</span> file descriptor, <span class="keyword">and</span> rejection can be implied by closing the <span class="keyword">new</span> socket.  Currently only DECNet has these semantics on Linux.</span><br><span class="line"></span><br><span class="line">       If flags is <span class="number">0</span>, then accept4() is the same as accept().  The following values can be bitwise ORed in flags to obtain different behavior:</span><br><span class="line"></span><br><span class="line">       SOCK_NONBLOCK   Set the O_NONBLOCK file status flag on the <span class="keyword">new</span> open file description.  Using <span class="keyword">this</span> flag saves extra calls to fcntl(<span class="number">2</span>) to achieve the same result.</span><br><span class="line"></span><br><span class="line">       SOCK_CLOEXEC    Set the close-on-exec (FD_CLOEXEC) flag on the <span class="keyword">new</span> file descriptor.  See the description of the O_CLOEXEC flag in open(<span class="number">2</span>) <span class="keyword">for</span> reasons why <span class="keyword">this</span> may be useful.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, these system calls <span class="keyword">return</span> a nonnegative integer that is a descriptor <span class="keyword">for</span> the accepted socket.  On error, <span class="number">-1</span> is returned, <span class="keyword">and</span> errno is <span class="built_in">set</span> appropriately.</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       read - read from a file descriptor</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       read() attempts to read up to count bytes from file descriptor fd into the buffer starting at buf.</span><br><span class="line"></span><br><span class="line">       On  files  that  support seeking, the read operation commences at the current file offset, <span class="keyword">and</span> the file offset is incremented by the number of bytes read.  If the current file offset is at <span class="keyword">or</span></span><br><span class="line">       past the end of file, no bytes are read, and read() returns zero.</span><br><span class="line"></span><br><span class="line">       If count is zero, read() may detect the errors described below.  In the absence of any errors, or if read() does not check for errors, a read() with a count of 0 returns zero and has no other</span><br><span class="line">       effects.</span><br><span class="line"></span><br><span class="line">       If count is greater than SSIZE_MAX, the result is unspecified.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       On  success, the number of bytes read is returned (zero indicates end of file), and the file position is advanced by this number.  It is not an error if this number is smaller than the number</span><br><span class="line">       of bytes requested; <span class="function"><span class="keyword">this</span> may happen <span class="keyword">for</span> example because fewer bytes are actually available right <span class="title">now</span> <span class="params">(maybe because we were close to end-of-file, <span class="keyword">or</span> because we are reading  from  a  pipe,  <span class="keyword">or</span></span></span></span><br><span class="line">       from a terminal), or because read() was interrupted by a signal.  See also NOTES.</span><br><span class="line"></span><br><span class="line">       On error, -1 is returned, and errno is set appropriately.  In this case, it is left unspecified whether the file position (if any) changes.</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       write - write to a file descriptor</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       write() writes up to count bytes from the buffer pointed buf to the file referred to by the file descriptor fd.</span><br><span class="line"></span><br><span class="line">       The number of bytes written may be less than count <span class="keyword">if</span>, <span class="keyword">for</span> example, there is insufficient space on the underlying physical medium, <span class="function"><span class="keyword">or</span> the RLIMIT_FSIZE resource limit is <span class="title">encountered</span> <span class="params">(see setr‐</span></span></span><br><span class="line">       limit(2)), or the call was interrupted by a signal handler after having written less than count bytes.  (See also pipe(7).)</span><br><span class="line"></span><br><span class="line">       For a seekable file (i.e., one to which lseek(2) may be applied, for example, a regular file) writing takes place at the current file offset, and the file offset is incremented by the  number</span><br><span class="line">       of bytes actually written.  If the file was open(2)ed with O_APPEND, the file offset is first set to the end of the file before writing.  The adjustment of the file offset and the write oper‐</span><br><span class="line">       ation are performed as an atomic step.</span><br><span class="line"></span><br><span class="line">       POSIX requires that a read(2) which can be proved to occur after a write() has returned returns the new data.  Note that not all filesystems are POSIX conforming.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, the number of bytes written is returned (zero indicates nothing was written).  It is not an error if this number is smaller than the number of bytes requested; this may happen for</span><br><span class="line">       example because the disk device was filled.  See also NOTES.</span><br><span class="line"></span><br><span class="line">       On error, <span class="number">-1</span> is returned, <span class="keyword">and</span> errno is <span class="built_in">set</span> appropriately.</span><br><span class="line"></span><br><span class="line">       If  count  is zero and fd refers to a regular file, then write() may return a failure status if one of the errors below is detected.  If no errors are detected, or error detection is not per‐</span><br><span class="line">       formed, <span class="number">0</span> will be returned without causing any other effect.  If count is zero <span class="keyword">and</span> fd refers to a file other than a regular file, the results are <span class="keyword">not</span> specified.</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/09/CSDN blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Just_Lm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="條路自己揀，僕街唔好喊。">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/CSDN blog/" itemprop="url">CSDN blog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-09T00:03:30+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="CSDN-blog"><a href="#CSDN-blog" class="headerlink" title="CSDN blog:"></a>CSDN blog:</h3><p>———————-<a href="http://blog.csdn.net/just_lm" target="_blank" rel="noopener">传送门</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/1.jpg"
                alt="Just_Lm" />
            
              <p class="site-author-name" itemprop="name">Just_Lm</p>
              <p class="site-description motion-element" itemprop="description">c++后台</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Just_Lm</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
